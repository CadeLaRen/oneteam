<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="chatpane-view">
    <resources>
      <stylesheet src="chrome://global/skin"/>
      <stylesheet src="chrome://oneteam/skin/chatpane/chatpane.css"/>
    </resources>

    <content>
      <html:iframe src="../content/blank.html" id="output" flex="1" onload="this._loaded = true;
                   try { this.parentNode._onLoad() } catch(e) {}"/>
      <xul:stack id="chatMarkers">
        <xul:vbox id="lastSeenMarker" collapsed2="true" class="marker-arrow"
                  style="top: 0"
                  onclick="this.parentNode.parentNode._moveToLastSeenMessage()"
                  tooltiptext="Move to last seen message"/>
      </xul:stack>
    </content>

    <implementation>
      <property name="smilesEnabled"
                onget="return this._output.contentDocument.body.className == 'smiles-enabled'"
                onset="this._output.contentDocument.body.className = val ? 'smiles-enabled' : '';
                       return val"/>

      <property name="model" onget="return this._model">
        <setter><![CDATA[
          if (val == this._model)
            return val;

          if (this._model)
            this._model.unregisterView(this._regToken);

          if (val) {
            this._regToken = val.registerView(this._onMessageQueueChanged, this, "messages");
            if (val.messages.length || !this._archiveMsgsAdded && val.archivedMessages.length)
              this._onMessageQueueChanged(val, "messages", {added: val.messages});
          }

          return this._model = val;
        ]]></setter>
      </property>

      <property name="visible" onget="return this._visible">
        <setter><![CDATA[
          if (!val == !this._visible)
            return this._visible = val;

          this._visible = val
          this._updateNonSeenStatus();

          if (!val && this._clearNonSeenMarkersTimeout) {
            window.clearTimeout(this._clearNonSeenMarkersTimeout);
            this._clearNonSeenMarkersTimeout = null;
          }

          if (!val && !this._firstNotSeenMsg)
            this._markMessagesAsSeen();

          return val;
        ]]></setter>
      </property>

      <constructor><![CDATA[
        var p = this.__proto__;
        this.__proto__ = {};

        var state = {};
        for each (var i in "visible model smilesEnabled".split(/ /))
          if (this[i] != null) {
            state[i] = this[i];
            delete this[i];
          }

        this.__proto__ = p;

        for (i in state)
          this[i] = state[i];

        if (this._visible == null)
          this._visible = true;

        this._output = document.getAnonymousElementByAttribute(this, "id", "output");
        this._lastSeenMarker = document.getAnonymousElementByAttribute(this, "id", "lastSeenMarker");
        this.colorMap = {0: 0};
        this.colorIndex = 1;
        this.colorTable = prefManager.getPref("chat.messages.colors").split(/\s*,\s*/);

        if (this._output._loaded && !this._initialized)
          this._onLoad();
      ]]></constructor>

      <destructor><![CDATA[
        this.destroy();
      ]]></destructor>

      <method name="destroy">
        <body><![CDATA[
          if (this._model && this._regToken)
            this._model.unregisterView(this._regToken);
          this._regToken = null;
        ]]></body>
      </method>

      <method name="_onLoad">
        <body>
          <![CDATA[
            this._initialized = true;

            var link = this._output.contentDocument.createElement("link");
// #ifdef XULAPP
            link.setAttribute("href", "chrome://oneteam/skin/chatpane/content.css");
/* #else
            link.setAttribute("href",
              document.location.href.replace(/content\/.*?$/, "skin/chatpane/content.css"));
// #endif */
            link.setAttribute("rel", "stylesheet");
            this._output.contentDocument.getElementsByTagName("HEAD")[0].appendChild(link);

            var colorScheme = ".message { opacity: 1 }\n.message[not-seen=\"true\"] { opacity: 1 }\n";
            var white = new RGBColor(1, 1, 1);
            for (var i = 0; i < this.colorTable.length; i++) {
              var base = new RGBColor(this.colorTable[i]);
              var bg = base.composite(white, 0.06);
              var border = base.composite(white, 0.3);

              colorScheme +=
                <style>
                  .message[color-id="{i}"] {"{"}
                      background: {bg};
                  }

                  .message[color-id="{i}"] {"{"}
                      border-color: {border};
                  }

                  .message[color-id="{i}"] > .header {"{"}
                      background-color: {base}
                  }

                  .meMessage.message[color-id="{i}"] {"{"}
                      color: {base}
                  }
                </style>;
            }

            var colorSchemeTag = this._output.contentDocument.createElement("style");
            colorSchemeTag.setAttribute("type", "text/css");
            colorSchemeTag.appendChild(this._output.contentDocument.createTextNode(colorScheme));
            this._output.contentDocument.getElementsByTagName("HEAD")[0].
              appendChild(colorSchemeTag);

            this._output.contentDocument.body.className = "smiles-enabled";

            for (var i = 0; i < account.style.smiles.length; i++)
              account.style.smiles[i].attachStyles(this._output.contentDocument);

            this._output.contentDocument.addEventListener("click", linkEventsRedirector, true)

            if (this._model && this._model.messages.length ||
                !this._archiveMsgsAdded && this._model.archivedMessages.length)
              this._onMessageQueueChanged(this._model, "messages", {added: this._model.messages});

            var doc = this._output.contentDocument;
            var me = this;

            this._output.contentWindow.addEventListener("resize", function() {
              me._updateNonSeenStatus();
              doc.body.scrollTop = doc.body.scrollHeight;
            }, false);
            this._output.contentWindow.addEventListener("scroll", function() {
              me._updateNonSeenStatus(true);
            }, false);
          ]]>
        </body>
      </method>

      <method name="_onMessageQueueChanged">
        <parameter name="model"/>
        <parameter name="name"/>
        <parameter name="arg"/>
        <body><![CDATA[
          if (!this._initialized || !arg || !arg.added)
            return;

          if (this._appendTimeout)
            window.clearTimeout(this._appendTimeout);
          this._appendTimeout = window.setTimeout(function(t){t._appendMessages()}, 50, this);
        ]]></body>
      </method>

      <method name="_updateNonSeenStatus">
        <parameter name="fromScroll"/>
        <body><![CDATA[
          var doc = this._output.contentDocument;

          if (!this._firstNotSeenMsg) {
            try {
              doc.styleSheets[1].cssRules[0].style.cssText = "opacity: 1";
            } catch (ex) {}
            return;
          }

          var body = doc.body;

          var p = this._firstNotSeenMsg;
          var top = 0;
          do {
            top += p.offsetTop;
            p = p.offsetParent;
          } while (p);


          var msgInViewport = top >= body.scrollTop && top < (body.scrollTop + body.clientHeight);

          if (msgInViewport)
            this._lastSeenMarker.style.borderRightColor = "transparent";
          else {
            this._lastSeenMarker.style.top = parseInt(top/body.scrollHeight*(body.clientHeight-8))+"px";
            this._lastSeenMarker.style.borderRightColor = "black";
          }

          if (fromScroll && this._clearNonSeenMarkersTimeout) {
            window.clearTimeout(this._clearNonSeenMarkersTimeout);
            this._clearNonSeenMarkersTimeout = null;
          }

          if (!this._clearNonSeenMarkersTimeout) {
            if (!this._visible)
              doc.styleSheets[1].cssRules[0].style.cssText = "opacity: 0.3";
            else if (msgInViewport)
              this._clearNonSeenMarkersTimeout = window.setTimeout(this._clearNonSeenMarkerFun, 3000, this);
          } else if (!msgInViewport) {
            window.clearTimeout(this._clearNonSeenMarkersTimeout);
            this._clearNonSeenMarkersTimeout = null;
          }
        ]]></body>
      </method>

      <method name="_clearNonSeenMarkerFun">
        <parameter name="_this"/>
        <body><![CDATA[
          _this._clearNonSeenMarkersTimeout = null;
          _this._lastSeenMarker.style.borderRightColor = "transparent";
          _this._firstNotSeenMsg = null;

          var token = {step: 0, steps: 20, el: _this, doc: _this._output.contentDocument};

          token.timeout = window.setInterval(function(t) {
            if (t.step++ == t.steps) {
              window.clearInterval(t.timeout);
              t.doc.styleSheets[1].cssRules[0].style.cssText = "opacity: 1";

              _this._markMessagesAsSeen();

              return;
            }
            t.doc.styleSheets[1].cssRules[0].style.cssText = "opacity: "+(0.3+0.7*t.step/t.steps);
          }, 20, token);
        ]]></body>
      </method>

      <method name="_moveToLastSeenMessage">
        <body><![CDATA[
          if (!this._firstNotSeenMsg)
            return;

          var p = this._firstNotSeenMsg;
          var top = 0;
          var body = this._output.contentDocument.body;
          do {
            top += p.offsetTop;
            p = p.offsetParent;
          } while (p);

          body.scrollTop = p - body.clientHeight/5;
        ]]></body>
      </method>

      <method name="_markMessagesAsSeen">
        <body><![CDATA[
          var els = this._output.contentDocument.getElementsByTagName("div");
          for (var i = els.length-1; i >= 0; i--)
            els[i].removeAttribute("not-seen");
        ]]></body>
      </method>

      <method name="_appendMessages">
        <body><![CDATA[
          var doc = this._output.contentDocument;

          if (!doc) {
            this._appendTimeout = window.setTimeout(function(t){t._appendMessages()}, 50, this);
            return
          }

          var scrollToBottom = doc.documentElement.scrollTop + doc.documentElement.clientHeight >=
            doc.documentElement.scrollHeight - 8;

          this._appendTimeout = null;

          if (!this._content) {
            this._content = doc.createElement("div");
            doc.body.appendChild(this._content);
          }

          var msgs = this._archiveMsgsAdded ? this._model.messages :
            this._model.archivedMessages.concat(this._model.messages);

          this._archiveMsgsAdded = true;

          var msgsChunk = doc.createDocumentFragment();

          for (var i = 0; i < msgs.length; i++) {
            var msg = msgs[i];

            var msgEl = doc.createElement("div");
            msgsChunk.appendChild(msgEl);
            msgEl.setAttribute("class", "message "+msg.classes);
            msgEl.setAttribute("not-seen", "true")

            if (msg.isSystemMessage) {
              msgEl.setAttribute("starts-chunk", "true");
              this._lastContactId = null;
            } else {
              if (!(msg.contactId in this.colorMap)) {
                this.colorMap[msg.contactId] = this.colorIndex;
                this.colorIndex = this.colorIndex%(this.colorTable.length-1) + 1;
              }

              msgEl.setAttribute("author-id", msg.contactId);
              msgEl.setAttribute("color-id", this.colorMap[msg.contactId]);

              if (this._lastContactId != msg.contactId || msg.time - this._lastMessageTime > 5*60*1000)
                msgEl.setAttribute("starts-chunk", "true");

              this._lastContactId = msg.contactId;
              this._lastMessageTime = msg.time;
            }

            if (!this._visible && !this._firstNotSeenMsg)
                this._firstNotSeenMsg = msgEl;

            var h = doc.createElement("span");
            h.setAttribute("class", "header");
            msgEl.appendChild(h);

            var e = doc.createElement("span");
            e.setAttribute("class", "to-copy-paste");
            e.appendChild(doc.createTextNode("["));
            h.appendChild(e);

            e = doc.createElement("span");
            e.setAttribute("class", "date");
            e.appendChild(doc.createTextNode(readableTimestamp(msg.time)));
            h.appendChild(e);

            e = doc.createElement("span");
            e.setAttribute("class", "to-copy-paste");
            e.appendChild(doc.createTextNode("] "));
            h.appendChild(e);

            if (!msg.isSystemMessage) {
              e = doc.createElement("span");
              e.setAttribute("class", "author");
              e.appendChild(doc.createTextNode(msg.nick));
              h.appendChild(e);

              e = doc.createElement("span");
              e.setAttribute("class", "to-copy-paste");
              e.appendChild(doc.createTextNode(": "));
              h.appendChild(e);
            }

            e = doc.createElement("span");
            e.setAttribute("class", "body");
            e.innerHTML = msg.formatedHtml;

            msgEl.appendChild(e);
          }

          this._content.appendChild(msgsChunk);

          this._model.removeMessages();

          if (!scrollToBottom)
            return;

          doc.documentElement.scrollTop = doc.documentElement.scrollHeight;

          this._updateNonSeenStatus();

          // To eliminate small gap from late style resolution, scroll
          // once more from timeout, but only if scroll position is still
          // this same.
          setTimeout(function(body, pos) {
              if (body.scrollTop == pos) body.scrollTop = body.scrollHeight
            }, 100, doc.documentElement, doc.documentElement.scrollTop);
        ]]></body>
      </method>

      <method name="clear">
        <body>
          <![CDATA[
            if (this._content)
              this._content.parentNode.removeChild(this._content);

            this._content = this._msgsContainer =
              this._lastMessageTime = this._lastContactId = null;

            this._archiveMsgsAdded = false;
          ]]>
        </body>
      </method>
    </implementation>
  </binding>

  <binding id="richtext-toolbar" extends="chrome://global/content/bindings/toolbar.xml#toolbar">
    <resources>
      <stylesheet src="chrome://global/skin"/>
      <stylesheet src="chrome://oneteam/skin/chatpane/textbox.css"/>
    </resources>

    <content tbalign="center">
      <xul:toolbarbutton id="boldButton" type="checkbox" cmd="bold" tooltiptext="_('Bold')"/>
      <xul:toolbarbutton id="italicButton" type="checkbox" cmd="italic" tooltiptext="_('Italic')"/>
      <xul:toolbarbutton id="underlineButton" type="checkbox" cmd="underline" tooltiptext="_('Underline')"/>
      <xul:toolbarseparator/>
      <xul:toolbarbutton id="biggerFontButton" cmd="increaseFontSize" tooltiptext="_('Increase font size')"/>
      <xul:toolbarbutton id="smallerFontButton" cmd="decreaseFontSize" tooltiptext="_('Decrease font size')"/>
      <xul:toolbarseparator/>
      <xul:toolbarbutton id="fontColorButton" cmd="foreColor" tooltiptext="_('Font color')"/>
      <xul:toolbarbutton id="fontBackgroundButton" cmd="hiliteColor" tooltiptext="_('Background color')"/>
      <children/>

      <xul:popupset>
        <xul:popup id="colorpicker">
          <xul:colorpicker allowevents="true"/>
        </xul:popup>
      </xul:popupset>
    </content>
    <implementation>

      <constructor><![CDATA[
        this._colorpicker = document.getAnonymousElementByAttribute(this, "id", "colorpicker");

        var el = this.nextSibling;
        if (el && el.localName != "textbox")
          el = el.firstChild;

        if (el && el.localName == "textbox" && el.getAttribute("type") == "resizable-richtext")
          this._textbox = el;
      ]]></constructor>

      <method name="_repairColor">
        <parameter name="color"/>
        <body>
          <![CDATA[
            var match;

            if (!color)
              return "#000000";
            else if (color == "transparent")
              return "#ffffff";
            if (match = color.match(/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/))
              return "#"+(+match[1]+256).toString(16).substr(1)+
                         (+match[2]+256).toString(16).substr(1)+
                         (+match[3]+256).toString(16).substr(1);
            return color;
          ]]>
        </body>
      </method>

      <method name="_updateState">
        <body><![CDATA[
        if (!this._textbox)
          return;
        for each (var cmd in "bold italic underline".split(" ")) {
          document.getAnonymousElementByAttribute(this, "cmd", cmd).checked =
            this._textbox._input.contentDocument.queryCommandState(cmd);
        }
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="popuphiding"><![CDATA[
        if (event.originalTarget != this._colorpicker)
          return;
        this._colorpicker.firstChild.removeKeyListener();
        this._colorpicker.firstChild.mIsPopup = false;
        this._colorButtonCmd = null;
      ]]></handler>

      <handler event="select"><![CDATA[
        if (event.originalTarget != this._colorpicker.firstChild || !this._colorButtonCmd)
          return;

        if (this._textbox)
          this._textbox._input.contentDocument.execCommand(this._colorButtonCmd, false,
            this._repairColor(this._colorpicker.firstChild.color));

        setTimeout(function(me) { me._colorpicker.hidePopup(); }, 0, this)
      ]]></handler>

      <handler event="command"><![CDATA[
        if (!this._textbox)
          return;

        var cmd = event.originalTarget.getAttribute("cmd");

        if (cmd == "foreColor" || cmd == "hiliteColor") {
          this._colorButtonCmd = cmd;

          this._colorpicker.firstChild.color = this._repairColor(this._textbox._input.
            contentDocument.queryCommandValue(cmd));

          this._colorpicker.firstChild.addKeyListener();
          this._colorpicker.firstChild.mIsPopup = true;

          setTimeout(function (popup, button) {
            popup.showPopup(button, -1, -1, "popup", "bottomleft", "topleft");
          }, 0, this._colorpicker, event.originalTarget);
        } else if (cmd) {
          this._textbox._input.contentDocument.execCommand(cmd, false, null);
          this._textbox.maybeResize();
        }
      ]]></handler>
    </handlers>
  </binding>

  <binding id="resizable-richtextbox">
    <resources>
      <stylesheet src="chrome://global/skin"/>
      <stylesheet src="chrome://oneteam/skin/chatpane/textbox.css"/>
    </resources>

    <content>
      <xul:vbox flex="1" class="inputBox">
        <html:iframe id="_input" style="height: 1em;" onload="this._loaded = 1;
          try{if (this.parentNode.parentNode._input) this.parentNode.parentNode._init()}catch(ex){}"/>
      </xul:vbox>
    </content>

    <implementation>
      <property name="value" onget="return this._input.contentDocument.body"
                onset="return this._input.contentDocument.body.innerHTML = val"/>

      <constructor><![CDATA[
        this._input = document.getAnonymousElementByAttribute(this, "id", "_input");

        var el = this.previousSibling;
        if (!el)
          el = this.parentNode.previousSibling;

        if (el && el.localName == "toolbar" && el.getAttribute("type") == "chatpane-commands")
          this._toolbar = el;

        setTimeout(function(body) { body.style.margin = "0"; }, 0,
                   this._input.contentDocument.body);

        this._history = [];
        this._historyPosition = 0;

        if (this._input._loaded && !this._initialized)
          this._init();
      ]]></constructor>

      <method name="_init">
        <body><![CDATA[
          var me = this;
          var doc = this._input.contentDocument;
          var win = this._input.contentWindow;

          this._initialized = true;

          var link = doc.createElement("link");
// #ifdef XULAPP
          link.setAttribute("href", "chrome://oneteam/skin/chatpane/content.css");
/* #else
          link.setAttribute("href",
            document.location.href.replace(/content\/.*?$/, "skin/chatpane/content.css"));
// #endif */
          link.setAttribute("rel", "stylesheet");
          doc.getElementsByTagName("HEAD")[0].appendChild(link);

          doc.designMode = "on";
          doc.body.style.margin = "0"
          doc.body.bgColor = "#ffffff";

          window.addEventListener("resize", function(){ me.maybeResize() }, false);

          doc.addEventListener("keypress", function (event) {
            if (event.keyCode == KeyEvent.DOM_VK_TAB) {
              event.preventDefault();

              var selection = me._input.contentWindow.getSelection();
              var range = me._input.contentDocument.createRange();

              range.setStart(me._input.contentDocument.body, 0);
              range.setEnd(selection.anchorNode, selection.anchorOffset);

              var res = me._tryCompletion(me._rangeContent(range), event.shiftKey);
              if (res != null) {
                range.deleteContents();
                me._input.contentDocument.execCommand("insertHTML", false, xmlEscape(res));
              }
              range.detach();
              return;
            }

            var upKey = event.keyCode == KeyEvent.DOM_VK_UP;
            if ((upKey || event.keyCode == KeyEvent.DOM_VK_DOWN) &&
                !event.shiftKey && !event.altKey && !event.ctrlKey &&
                !event.metaKey && me._input.selectionStart == me._input.selectionEnd)
              if (me._handleHistoryKey(upKey)) {
                event.preventDefault();
                event.stopPropagation();
                return false;
              }

            var inputValue;
            if (event.keyCode == KeyEvent.DOM_VK_RETURN) {
              if ((inputValue = me._send(!event.shiftKey)) != null) {
                if (inputValue) {
                  if (!me._history.length || me._history[me._history.length-1] != inputValue)
                    me._history.push(inputValue);
                  me._historyPosition = me._history.length;
                }

                event.stopPropagation();
                event.preventDefault();

                me.clear();
              } else
                return false;
            }
            return true;
          }, true);

          for each (var event in "keypress keyup keydown click mousedown mouseup dragdrop".split(" ")) {
            doc.addEventListener(event, function(event){
              if (me._toolbar)
                me._toolbar._updateState(event);
              me.maybeResize()
            }, false);
          }

          win.focus();

          this.maybeResize()

          doc = win = null;
        ]]></body>
      </method>

      <method name="focus">
        <body><![CDATA[
          if (this._input)
            setTimeout(function(el){el.focus()}, 100, this._input.contentWindow);
        ]]></body>
      </method>

      <method name="clear">
        <body><![CDATA[
          this._input.contentDocument.execCommand("selectAll", false, null);
          this._input.contentDocument.execCommand("delete", false, null);
          this.maybeResize();
        ]]></body>
      </method>

      <method name="_append">
        <parameter name="str"/>
        <body><![CDATA[
          this._input.contentDocument.execCommand("insertHTML", false, xmlEscape(str));
        ]]></body>
      </method>

      <method name="_rangeContent">
        <parameter name="range"/>
        <body><![CDATA[
          function toStr(node) {
            if (node.nodeType == node.TEXT_NODE)
              return node.nodeValue;
            if (node.nodeName == "BR")
              return "\n";

            var res = "";
            for (var i = 0; i < node.childNodes.length; i++)
              res += arguments.callee(node.childNodes[i]);
            return res;
          }

          return toStr(range.cloneContents());
        ]]></body>
      </method>

      <method name="_tryCompletion">
        <body><![CDATA[
        ]]></body>
      </method>

      <method name="_send">
        <parameter name="withEnter"/>
        <body><![CDATA[
          return withEnter ? null : this._input.value;
        ]]></body>
      </method>

      <method name="_blink">
        <parameter name="me"/>
        <body><![CDATA[
          if (this == me || !me) {
            me = this;
            this._blinkSteps = 20;
            this._blinkStep = 0;
            this._blinkSrcColors = document.defaultView.
              getComputedStyle(this, "").borderTopColor.
                replace(/[^\d,\.]/g, "").split(/,/);

            var n = this._input.parentNode, c;
            while ((c = document.defaultView.getComputedStyle(n, "").
                    backgroundColor) == "transparent")
              n = n.parentNode;
            this._blinkTargetColors = c.replace(/[^\d,\.]/g, "").split(/,/);

            if (this._blinkSrcColors.length != this._blinkTargetColors.length)
              if (this._blinkSrcColors.length == 4)
                this._blinkTargetColors.push(1);
              else
                this._blinkSrcColors.push(1);

            if (me._blinkTimeout)
              return;
          }

          if (me._blinkStep == me._blinkSteps) {
            me._input.style.outline = "";
            delete me._blinkTimeout;
            return;
          }

          var color = [];
          for (var i = 0; i < me._blinkSrcColors.length; i++)
            color[i] = Math.round((
              me._blinkSrcColors[i]*(me._blinkSteps-me._blinkStep)+
              me._blinkTargetColors[i]*me._blinkStep)/me._blinkSteps);
          me.style.outline = "3px solid "+
            (color.length == 3 ? "rgb(" : "rgba(") + color.join(",")+")";
          me._blinkStep++;
          me._blinkTimeout = window.setTimeout(me._blink, 20, me);
        ]]></body>
      </method>

      <method name="maybeResize">
        <body><![CDATA[
          setTimeout(this._maybeResize, 0, this);
        ]]></body>
      </method>

      <method name="_maybeResize">
        <parameter name="me"/>
        <body><![CDATA[
          me._preMaybeResize();

          var h = me._input.contentDocument.body.parentNode.offsetHeight;

          if (me._sizeDiff == null) {
            me._sizeDiff = me._input.parentNode.boxObject.height - me._input.clientHeight;
          }

          if (h < 10)
            h = 10;

          if (h > 0.3*window.innerHeight) {
            me._input.contentDocument.body.style.overflow = "auto"
            h = 0.3*window.innerHeight;
          } else
            me._input.contentDocument.body.style.overflow = "hidden";

          me._input.style.height = (h) + "px";
          //me._input.parentNode.style.height = (h+me._sizeDiff) + "px";

          me._postMaybeResize();
        ]]></body>
      </method>

      <method name="_preMaybeResize">
        <body> </body>
      </method>

      <method name="_postMaybeResize">
        <body> </body>
      </method>

      <method name="_handleHistoryKey">
        <parameter name="up"/>
        <body><![CDATA[
          var histPos = this._historyPosition + (up ? -1 : 1);

          if (histPos < 0 || histPos > this._history.length)
            return false;

          var selection = this._input.contentWindow.getSelection();
          var range = this._input.contentDocument.createRange();

          if (up) {
            range.setStart(this._input.contentDocument.body, 0);
            range.setEnd(selection.anchorNode, selection.anchorOffset);
          } else {
            range.setStart(selection.focusNode, selection.focusOffset);
            range.setEndAfter(this._input.contentDocument.body);
          }

          var val = this.value.innerHTML.replace(/<br>$/, "");
          var rangeContent = this._rangeContent(range)

          if (rangeContent && rangeContent != "\n")
            return false;

          if (this._historyPosition < this._history.length && val)
            this._history[this._historyPosition] = val;

          this.clear();
          if (histPos < this._history.length) {
            this._input.contentDocument.execCommand("insertHTML", false, this._history[histPos]);
            selection = this._input.contentWindow.getSelection();
            selection.selectAllChildren(this._input.contentDocument.body);
            if (up)
              selection.collapseToEnd();
            else
              selection.collapseToStart();
          }

          this._historyPosition = histPos;
          this.maybeResize();

          return true;
        ]]></body>
      </method>
    </implementation>
  </binding>

  <binding id="chatpane-toolbar" extends="chatpane.xml#richtext-toolbar">
    <resources>
      <stylesheet src="chrome://global/skin"/>
      <stylesheet src="chrome://oneteam/skin/chatpane/textbox.css"/>
    </resources>

    <content tbalign="center">
      <xul:toolbarbutton id="boldButton" type="checkbox" cmd="bold" tooltiptext="_('Bold')"/>
      <xul:toolbarbutton id="italicButton" type="checkbox" cmd="italic" tooltiptext="_('Italic')"/>
      <xul:toolbarbutton id="underlineButton" type="checkbox" cmd="underline" tooltiptext="_('Underline')"/>
      <xul:toolbarseparator/>
      <xul:toolbarbutton id="biggerFontButton" cmd="increaseFontSize" tooltiptext="_('Increase font size')"/>
      <xul:toolbarbutton id="smallerFontButton" cmd="decreaseFontSize" tooltiptext="_('Decrease font size')"/>
      <xul:toolbarseparator/>
      <xul:toolbarbutton id="fontColorButton" cmd="foreColor" tooltiptext="_('Font color')"/>
      <xul:toolbarbutton id="fontBackgroundButton" cmd="hiliteColor" tooltiptext="_('Background color')"/>
      <xul:toolbarseparator/>
      <xul:toolbarbutton id="vcardButton" oncommand="this.parentNode.model.showVCard()"
                         tooltiptext="_('Show contact information')"/>
      <xul:toolbarbutton id="sendFile" oncommand="this.parentNode._model.onSendFile()"
                         tooltiptext="_('Send file')"/>
      <xul:toolbarbutton id="extraCmds" tooltiptext="_('Extra Commands')" type="menu">
        <xul:menupopup onpopupshowing="this.parentNode.parentNode._syncMenu()">
          <xul:menuitem label="_('Invite to group chat room')"
                        onmenushowing="this.hidden = contact instanceof ConferenceMember ||
                                       contact instanceof Conference;
                                       this.disabled = account.conferences.length == 0"
                        oncommand="this.parentNode.parentNode.parentNode._model.onInvite()"/>
          <xul:menuitem label="_('Invite contact')"
                        onmenushowing="this.hidden = !(contact instanceof Conference)"
                        oncommand="this.parentNode.parentNode.parentNode._model.onInvite()"/>
          <xul:menuitem label="_('Invite user by mail')"
                        onmenushowing="this.hidden = !(contact instanceof Conference)"
                        oncommand="this.parentNode.parentNode.parentNode._model.onInviteByMail()"/>
        </xul:menupopup>
      </xul:toolbarbutton>
      <xul:toolbarseparator/>
      <xul:toolbarbutton id="smilesList" type="smiles-list"
                         tooltiptext="_('Toggle smiles visibility/select smile')"/>

      <xul:popupset>
        <xul:popup id="colorpicker">
          <xul:colorpicker allowevents="true"/>
        </xul:popup>
      </xul:popupset>
    </content>

    <implementation>
      <property name="model" onget="return this._model">
        <setter><![CDATA[
          this._model = val;

          this._sendFile.hidden = !val || typeof(socks5Service) == "undefined" ||
            !socks5Service.canSendTo(val.contact ? val : val.activeResource);
          this._syncMenu();
        ]]></setter>
      </property>

      <constructor><![CDATA[
        this._sendFile = document.getAnonymousElementByAttribute(this, "id", "sendFile");
        this._extraCmds = document.getAnonymousElementByAttribute(this, "id", "extraCmds");

        var p = this.__proto__;
        this.__proto__ = {};

        var state = {};
        for each (var i in "model".split(/ /))
          if (this[i] != null) {
            state[i] = this[i];
            delete this[i];
          }

        this.__proto__ = p;

        for (i in state)
          this[i] = state[i];
      ]]></constructor>

      <method name="_syncMenu">
        <body><![CDATA[
          var list = this._extraCmds.firstChild.childNodes;
          var hasAnyEntry = false;

          for (var i = 0; i < list.length; i++) {
            if (!list[i].onmenushowing)
              list[i].onmenushowing = new Function("contact", list[i].getAttribute("onmenushowing"));

            list[i].onmenushowing(this._model);

            if (!list[i].hidden)
              hasAnyEntry = true;
          }

          this._extraCmds.hidden = !hasAnyEntry;
       ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="selectedSmile">
        <![CDATA[
          if (this._textbox)
            this._textbox._append(event.originalTarget.selectedSmile.texts[0]);
        ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="chatpane">

    <resources>
      <stylesheet src="chrome://global/skin"/>
      <stylesheet src="chrome://oneteam/skin/chatpane/chatpane.css"/>
    </resources>

    <content>
      <xul:vbox flex="1" smiles-enabled="true">
        <xul:contactinfo id="contactInfo"/>

        <xul:chatpane-view id="output-pane" flex="1"/>

        <xul:toolbar type="chatpane-commands"/>

        <xul:hbox align="center">
          <xul:textbox type="resizable-richtext" id="input" flex="1" multiline="true"/>
          <xul:button id="send" oncommand="this.parentNode.parentNode.parentNode._send()"/>
        </xul:hbox>
      </xul:vbox>
    </content>

    <implementation>

      <property name="hasSubject"
        onset="this._subject.parentNode.hidden = !val; return val"
        onget="return !this._subject.parentNode.hidden" />

      <property name="subject"
        onset="return this._subject.value = val"
        onget="return this._subject.value" />

      <property name="userTypingHandler"
        onset="return this._input.userTypingHandler = val"
        onget="return this._input.userTypingHandler" />

      <property name="focusHandler"
        onset="this._attachFocusHandler(this, val); return val"
        onget="return this._focusHandler" />

      <property name="model" onget="return this._model">
        <setter><![CDATA[
          this._model = val;
          this._contactInfo.model = val && val.contact;
          this._output.model = val;
          this._chatpaneCommands.model = val && val.contact;
          this.completionEngine = val && val.contact.createCompletionEngine();

          return val;
        ]]></setter>
      </property>

      <constructor><![CDATA[
        this.sendOnEnter = this.getAttribute("sendonenter") != "false";

        this._input = document.getAnonymousElementByAttribute(this, "id", "input");
        this._output = document.getAnonymousElementByAttribute(this, "id", "output-pane");
        this._subject = document.getAnonymousElementByAttribute(this, "id", "subject");
        this._contactInfo = document.getAnonymousElementByAttribute(this, "id", "contactInfo");
        this._chatpaneCommands = document.getAnonymousElementByAttribute(this, "type", "chatpane-commands");
        this._smilesList = document.getAnonymousElementByAttribute(this, "id", "smilesList");

        this._input._tryCompletion = new Callback(this._tryCompletion, this);
        this._input._send = new Callback(this._send, this);
        this._input._preMaybeResize = new Callback(this._preMaybeResize, this);
        this._input._postMaybeResize = new Callback(this._postMaybeResize, this);

        var p = this.__proto__;
        this.__proto__ = {};

        var state = {};
        for each (var i in "model userTypingHandler focusHandler".split(/ /))
          if (this[i] != null) {
            state[i] = this[i];
            delete this[i];
          }

        this.__proto__ = p;

        for (i in state)
          this[i] = state[i];

        setTimeout(function(me) {
          if (!me._output._output) {
            setTimeout(arguments.callee, 10, me);
            return;
          }
          me._output._output.contentWindow.addEventListener("keypress", function(event) {
            if (event.charCode && !event.ctrlKey && !event.altKey) {
              me._input._append(String.fromCharCode(event.charCode));
              me.focus();
            }
          }, false);
        }, 0, this);
      ]]></constructor>

      <method name="destroy">
        <body><![CDATA[
          this._output.destroy()
        ]]></body>
      </method>

      <method name="_attachFocusHandler">
        <parameter name="_this"/>
        <parameter name="handler"/>
        <parameter name="internal"/>
        <body><![CDATA[
          if (!internal) {
            if (_this._focusHandler == handler)
              return;
            _this._focusHandler = handler;
          } else
            delete _this._focusHandlerAttachTimeout;

          if (!_this._output || !_this._input ||
              !_this._output._initialized || !_this._input._initialized)
          {
            if (_this._focusHandlerAttachTimeout == null)
              _this._focusHandlerAttachTimeout = window.setTimeout(arguments.callee, 10, _this, null, true);
            return;
          }

          if (_this._focusHandler) {
            if (!_this._focusHandlers) {
              _this._focusHandlers = [];
              _this._focusHandlers[0] = function(event) {
                if (event.target.nodeType == 9 && _this._focusHandler)
                  _this._focusHandler._windowFocusHandler(_this._focusHandler, event);
              };
              _this._focusHandlers[1] = function(event) {
                if (event.target.nodeType == 9 && _this._focusHandler)
                  _this._focusHandler._windowBlurHandler(_this._focusHandler, event);
              };
            }
            if (!_this._focusHandlerAttached) {
              _this._input._input.contentWindow.addEventListener("focus", _this._focusHandlers[0], true);
              _this._input._input.contentWindow.addEventListener("blur", _this._focusHandlers[1], true);
              _this._output._output.contentWindow.addEventListener("focus", _this._focusHandlers[0], true);
              _this._output._output.contentWindow.addEventListener("blur", _this._focusHandlers[1], true);
              _this._focusHandlerAttached = true;
            }
          } else if (_this._focusHandlerAttached) {
            _this._input._input.contentWindow.removeEventListener("focus", _this._focusHandlers[0], true);
            _this._input._input.contentWindow.removeEventListener("blur", _this._focusHandlers[1], true);
            _this._output._output.contentWindow.removeEventListener("focus", _this._focusHandlers[0], true);
            _this._output._output.contentWindow.removeEventListener("blur", _this._focusHandlers[1], true);
            _this._focusHandlerAttached = false;
          }
        ]]></body>
      </method>

      <method name="focus">
        <body><![CDATA[
          this._input.focus();
        ]]></body>
      </method>

      <method name="clear">
        <body><![CDATA[
          this._input.clear();
        ]]></body>
      </method>

      <method name="clearOutput">
        <body><![CDATA[
          this._output.clear();
        ]]></body>
      </method>

      <method name="_tryCompletion">
        <parameter name="str"/>
        <body><![CDATA[
          if (!this.completionEngine)
            return;
          var res = this.completionEngine.complete(str);
          if (res == null)
            this._input._blink();
          return res;
        ]]></body>
      </method>

      <method name="_preMaybeResize">
        <body><![CDATA[
          if (!this._output || !this._output._output || !this._output._output.contentDocument)
            return;

          var outputBody = this._output._output.contentDocument.body;
          this._outputScrollPos = outputBody.scrollTop + outputBody.clientHeight;
        ]]></body>
      </method>

      <method name="_postMaybeResize">
        <body><![CDATA[
          var outputBody = this._output._output.contentDocument.body;
          outputBody.scrollTop = this._outputScrollPos - outputBody.clientHeight;
        ]]></body>
      </method>

      <method name="_send">
        <parameter name="withEnter"/>
        <body><![CDATA[
          if (!this.sendOnEnter || !withEnter)
            return null;

          var text = this._input.value.textContent;

          if (~text.search(/\S/)) {
            if (!this.completionEngine || !this.completionEngine.execCommand(text)) {
              var ev = document.createEvent("Events");
              ev.initEvent("chat-send", true, false);
              this.dispatchEvent(ev);

              if (this.userTypingHandler)
                this.userTypingHandler(-1);

              var body = this._input.value;
              if (body.lastChild.localName == "BR")
                body.removeChild(body.lastChild);

              var myResource = this._model.contact instanceof ConferenceMember ?
                this._model.contact.contact.myResource : account.myResource;

              var msg = new Message(null, body, myResource,
                                    this._model.contact instanceof Conference ? 1 : 3,
                                    null, this._model)

              this._model.sendMessage(msg);

              return msg.html;
            }
          }
          return "";
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="smilesToggle">
        <![CDATA[
          var enabled = this._contactInfo.parentNode.getAttribute("smiles-enabled") != "true"
          this._contactInfo.parentNode.setAttribute("smiles-enabled", enabled);
          this._output.smilesEnabled = enabled;
        ]]>
      </handler>
    </handlers>
  </binding>
</bindings>
