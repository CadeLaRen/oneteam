<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="chatpane-view">
    <resources>
      <stylesheet src="chrome://global/skin"/>
      <stylesheet src="chrome://oneteam/skin/chatpane/chatpane.css"/>
    </resources>

    <content>
      <html:iframe id="output" flex="1"/>
    </content>

    <implementation>
      <property name="smilesEnabled"
                onget="this._output.contentDocument.body.className == 'smiles-enabled'"
                onset="this._output.contentDocument.body.className = val ? 'smiles-enabled' : '';
                       return val"/>
      <constructor>
        <![CDATA[
          var me = this;

          this._msgs = [];
          this._output = document.getAnonymousElementByAttribute(this, "id", "output");
// #ifdef XULAPP
          this._output.contentWindow.addEventListener("load", function(){me._onLoad()}, false);
/* #else
          this._output.addEventListener("load", function(){me._onLoad()}, false);
// #endif */
          this.colorMap = {0: 0};
          this.colorIndex = 1;
          this.colorTable = [
            "#ff0000", "#6978a3",
            "#46a", "#c4d", "#3b3", "#fa4", "#79c", "#a7a",
            "#4ca", "#c66", "#aaa", "#ca0", "#770", "#5cc",
          ];
        ]]>
      </constructor>

      <method name="_onLoad">
        <parameter name="event"/>
        <body>
          <![CDATA[
            if (!this._msgs)
              return;

            this._output.contentDocument.body.style.MozUserFocus = "ignore";

            var link = this._output.contentDocument.createElement("link");
// #ifdef XULAPP
            link.setAttribute("href", "chrome://oneteam/skin/chatpane/content.css");
/* #else
            link.setAttribute("href",
              document.location.href.replace(/content\/.*?$/, "skin/chatpane/content.css"));
// #endif */
            link.setAttribute("rel", "stylesheet");
            this._output.contentDocument.getElementsByTagName("HEAD")[0].appendChild(link);

            var colorScheme = "";
            var white = new RGBColor(1, 1, 1);
            for (var i = 0; i < this.colorTable.length; i++) {
              var base = new RGBColor(this.colorTable[i]);
              var bg = base.composite(white, 0.06);
              var border = base.composite(white, 0.3);

              colorScheme +=
                <style>
                  .messageChunk[color-id="{i}"] {"{"}
                      background: {bg};
                  }

                  .messageChunk[color-id="{i}"], .messageChunk[color-id="{i}"] .message {"{"}
                      border-color: {border};
                  }

                  .messageChunk[color-id="{i}"] .header {"{"}
                      background-color: {base}
                  }
                  .messageChunk[color-id="{i}"] .meMessage {"{"}
                      color: {base}
                  }
                </style>;
            }

            var colorSchemeTag = this._output.contentDocument.createElement("style");
            colorSchemeTag.setAttribute("type", "text/css");
            colorSchemeTag.appendChild(this._output.contentDocument.createTextNode(colorScheme));
            this._output.contentDocument.getElementsByTagName("HEAD")[0].
              appendChild(colorSchemeTag);

            this._output.contentDocument.body.className = "smiles-enabled";

            for (var i = 0; i < account.style.smiles.length; i++)
              account.style.smiles[i].attachStyles(this._output.contentDocument);

            this._output.contentDocument.addEventListener("click", linkEventsRedirector, true)

            var msgs = this._msgs;
            this._msgs = null;
            for (var i = 0; i < msgs.length; i++)
              this.addMessage(msgs[i]);
          ]]>
        </body>
      </method>

      <method name="_performDomAppends">
        <parameter name="me"/>
        <body><![CDATA[
          var doc = me._output.contentDocument;

          if (me._clusterFragments)
            me._lastInDomCluster.appendChild(me._clusterFragments);

          if (me._contentFragments)
            me._content.appendChild(me._contentFragments);

          me._contentFragments = me._clusterFragments =
            me._lastInDomCluster = null;

          if (!me._scrollToBottom)
            return;

          doc.body.scrollTop = doc.body.scrollHeight;

          // To eliminate small gap from late style resolution, scroll
          // once more from timeout, but only if scroll position is still
          // this same.
          setTimeout(function(body, pos) {
              if (body.scrollTop == pos) body.scrollTop = body.scrollHeight
            }, 100, doc.body, doc.body.scrollTop);
        ]]></body>
      </method>

      <method name="_scheduleDomAppend">
        <parameter name="parentEl"/>
        <parameter name="childEl"/>
        <body><![CDATA[
          var doc = this._output.contentDocument;

          if (!this._lastInDomCluster) {
            this._lastInDomCluster = this._messagesCluster;
            this._scrollToBottom = doc.body.scrollTop + doc.body.clientHeight >=
              doc.body.scrollHeight - 8;

            setTimeout(this._performDomAppends, 50, this);
          }

          if (parentEl == this._content) {
            if (!this._contentFragments)
              this._contentFragments = doc.createDocumentFragment();
            this._contentFragments.appendChild(childEl);
          } else if (parentEl == this._lastInDomCluster) {
            if (!this._clusterFragments)
              this._clusterFragments = doc.createDocumentFragment();
            this._clusterFragments.appendChild(childEl);
          } else
            parentEl.appendChild(childEl);
        ]]></body>
      </method>

      <method name="addMessage">
        <parameter name="message"/>
        <body>
          <![CDATA[
            if (this._msgs) {
              this._msgs.push(message);
              return;
            }

            var doc = this._output.contentDocument;

            if (!this._content) {
              this._content = doc.createElement("div");
              doc.body.appendChild(this._content);
            }

            if (message.isSystemMessage) {
              var messageEl = doc.createElement("div");

              messageEl.setAttribute("class", "systemMessage");
              messageEl.innerHTML = message.formatedHtml;

              this._scheduleDomAppend(this._content, messageEl);
              this._messagesCluster = this._lastContactId = null;
              return;
            }

            if (!this._messagesCluster || this._lastContactId != message.contactId ||
                message.time - this._lastMessageTime > 5*60*1000)
            {
              this._messagesCluster = doc.createElement("div");
              this._lastContactId = message.contactId;
              this._lastMessageTime = message.time;

              if (!(message.contactId in this.colorMap)) {
                this.colorMap[message.contactId] = this.colorIndex;
                this.colorIndex = this.colorIndex%(this.colorTable.length-1) + 1;
              }
              this._messagesCluster.setAttribute("class", "messageChunk");
              this._messagesCluster.setAttribute("author-id", message.contactId);
              this._messagesCluster.setAttribute("color-id", this.colorMap[message.contactId]);
              this._scheduleDomAppend(this._content, this._messagesCluster);
            }

            messageEl = doc.createElement("div");
            messageEl.setAttribute("class", "message");

            this._scheduleDomAppend(this._messagesCluster, messageEl);

            var h = doc.createElement("div");
            h.setAttribute("class", "header");
            messageEl.appendChild(h);

            var e = doc.createElement("div");
            e.setAttribute("class", "author");
            e.appendChild(doc.createTextNode(message.nick));
            h.appendChild(e);

            e = doc.createElement("div");
            e.setAttribute("class", "date");
            e.appendChild(doc.createTextNode(readableTimestamp(message.time)));
            h.appendChild(e);

            e = doc.createElement("div");
            e.setAttribute("class", "body "+message.classes);
            e.innerHTML = message.formatedHtml;

            messageEl.appendChild(e);
          ]]>
        </body>
      </method>

      <method name="clear">
        <body>
          <![CDATA[
            if (this._content)
              this._content.parentNode.removeChild(this._content);

            this._messagesCluster = this._lastContactId =
              this._contentFragments = this._clusterFragments =
              this._content = this._lastInDomCluster =
              this._scrollToBottom = null;
          ]]>
        </body>
      </method>
    </implementation>
  </binding>

  <binding id="chatpane">

    <resources>
      <stylesheet src="chrome://global/skin"/>
      <stylesheet src="chrome://oneteam/skin/chatpane/chatpane.css"/>
    </resources>

    <content>
      <xul:vbox flex="1" smiles-enabled="true">
        <xul:contactinfo id="contactInfo"/>

        <xul:chatpane-view id="output-pane" flex="1"/>

        <xul:toolbox class="toolbox-top">
          <xul:toolbar tbalign="center">
            <xul:toolbarbutton id="smilesList" type="smiles-list"/>
          </xul:toolbar>
        </xul:toolbox>

        <xul:hbox align="center">
          <xul:deck flex="1">
            <xul:textbox id="input" flex="1" multiline="true" style="height: 1.7em"
                         oninput="this.parentNode.parentNode.parentNode.parentNode.maybeResize()"/>
            <xul:vbox flex="1">
              <xul:textbox id="inputClone" multiline="true" style="height: 1.7em"/>
            </xul:vbox>
          </xul:deck>
          <xul:button id="send" oncommand="this.parentNode.parentNode.parentNode._send()"/>
        </xul:hbox>
      </xul:vbox>
    </content>

    <implementation>

      <property name="content" readonly="true"
        onget="return this._input.value.replace(/\n$/, '')" />

      <property name="hasSubject"
        onset="this._subject.parentNode.hidden = !val; return val"
        onget="return !this._subject.parentNode.hidden" />

      <property name="subject"
        onset="return this._subject.value = val"
        onget="return this._subject.value" />

      <property name="model" onget="return this._model">
        <setter><![CDATA[
          this._model = val;
          this._contactInfo.model = val;
          this.completionEngine = val ? val.createCompletionEngine() : null;

          return val;
        ]]></setter>
      </property>

      <constructor>
        <![CDATA[
          this._scrollSize = 0;
          this.sendOnEnter = this.getAttribute("sendonenter") != "false";

          this._input = document.getAnonymousElementByAttribute(this, "id", "input");
          this._inputClone = document.getAnonymousElementByAttribute(this, "id", "inputClone");
          this._output = document.getAnonymousElementByAttribute(this, "id", "output-pane");
          this._subject = document.getAnonymousElementByAttribute(this, "id", "subject");
          this._contactInfo = document.getAnonymousElementByAttribute(this, "id", "contactInfo");
          this._smilesList = document.getAnonymousElementByAttribute(this, "id", "smilesList");
          this._history = [];
          this._historyPosition = 0;

          if (this._model != this.model) {
            var model = this.model;
            delete this.model;
            this.model = model;
          }

          var me = this;
          this._input.addEventListener("keypress",
            function (event) {
              if (event.keyCode == KeyEvent.DOM_VK_TAB) {
                event.preventDefault();
                if (me.completionEngine)
                  if (!me.completionEngine.complete(me._input))
                    me._blink();
              }

              var upKey = event.keyCode == KeyEvent.DOM_VK_UP;
              if ((upKey || event.keyCode == KeyEvent.DOM_VK_DOWN) &&
                  !event.shiftKey && !event.altKey && !event.ctrlKey &&
                  !event.metaKey && me._input.selectionStart == me._input.selectionEnd)
                if (me._handleHistoryKey(upKey))
                  return false;

              if (event.keyCode == KeyEvent.DOM_VK_RETURN &&
                  !event.shiftKey && me.sendOnEnter)
              {
                me._send();

                event.stopPropagation();
                event.preventDefault();
                return false;
              }
              return true;
            }, true);
          //this.maybeResize();

          this._output.addEventListener(
            "mouseup", function(event) {
              if(!me._output._output.contentWindow.getSelection().toString()) {
                event.stopPropagation();
                me.focus();
              }
            }, false);
        ]]>
      </constructor>

      <method name="clear">
        <body>
          <![CDATA[
            this._input.value = ""
            this.maybeResize();
          ]]>
        </body>
      </method>

      <method name="addMessage">
        <parameter name="msg"/>
        <parameter name="thread"/>
        <body>
          <![CDATA[
            if (!this._thread)
              this._thread = new MessageThread(thread);
            else if (thread)
              this._thread._threadID = thread;

            msg.thread = this._thread;
            this._output.addMessage(msg);
          ]]>
        </body>
      </method>

      <method name="clearView">
        <body>
          <![CDATA[
            this._output.clear();
          ]]>
        </body>
      </method>

      <method name="_handleHistoryKey">
        <parameter name="up"/>
        <body>
          <![CDATA[
            var histPos = this._historyPosition + (up ? -1 : 1);

            if (histPos < 0 || histPos >= this._history.length)
              return false;

            var height = this._inputClone.inputField.scrollHeight;
            var cursPos = this._input.selectionStart;

            if (up)
              this._inputClone.value = this._inputClone.value.substr(cursPos);
            else
              this._inputClone.value = this._inputClone.value.substr(0, cursPos);

            var newHeight = this._inputClone.inputField.scrollHeight;
            if (newHeight < height-4 || newHeight > height+4) {
              this._inputClone.value = this._input.value;
              return false;
            }

            if (this._history[this._historyPosition] != this._input.value)
              this._history[this._historyPosition] =
                [this._input.value, this._input.selectionStart];

            this._input.value = this._history[histPos][0];
            window.setTimeout(function(i, p){i.selectionStart = i.selectionEnd = p},
                              0, this._input, this._history[histPos][1]);
            this._historyPosition = histPos;
            this.maybeResize();

            return true;
          ]]>
        </body>
      </method>

      <method name="_blink">
        <parameter name="me"/>
        <body>
          <![CDATA[
            if (this == me || !me) {
              me = this;
              this._blinkSteps = 20;
              this._blinkStep = 0;
              this._blinkSrcColors = document.defaultView.
                getComputedStyle(this._input, "").borderTopColor.
                  replace(/[^\d,\.]/g, "").split(/,/);

              var n = this._input.parentNode, c;
              while ((c = document.defaultView.getComputedStyle(n, "").
                      backgroundColor) == "transparent")
                n = n.parentNode;
              this._blinkTargetColors = c.replace(/[^\d,\.]/g, "").split(/,/);

              if (this._blinkSrcColors.length != this._blinkTargetColors.length)
                if (this._blinkSrcColors.length == 4)
                  this._blinkTargetColors.push(1);
                else
                  this._blinkSrcColors.push(1);

              if (me._blinkTimeout)
                return;
            }

            if (me._blinkStep == me._blinkSteps) {
              me._input.style.outline = "";
              delete me._blinkTimeout;
              return;
            }

            var color = [];
            for (var i = 0; i < me._blinkSrcColors.length; i++)
              color[i] = Math.round((
                me._blinkSrcColors[i]*(me._blinkSteps-me._blinkStep)+
                me._blinkTargetColors[i]*me._blinkStep)/me._blinkSteps);
            me._input.style.outline = "3px solid "+
              (color.length == 3 ? "rgb(" : "rgba(") + color.join(",")+")";
            me._blinkStep++;
            me._blinkTimeout = window.setTimeout(me._blink, 20, me);
          ]]>
        </body>
      </method>

      <method name="_send">
        <body>
          <![CDATA[
            if (~this.content.search(/\S/)) {
              if (!this.completionEngine || !this.completionEngine.execCommand(this._input)) {
                this._history.push([this.content, this._input.selectionEnd]);
                this._historyPosition = this._history.length;

                var ev = document.createEvent("Events");
                ev.initEvent("chat-send", true, false);
                this.dispatchEvent(ev);

                var body = this.content;
                if (!(this._model instanceof Conference)) {
                  var myResource = this._model instanceof ConferenceMember ?
                    this._model.contact.myResource : account.myResource;
                  this.addMessage(new Message(body, null, myResource, 0));
                }

                if (!this._thread)
                  this._thread = new MessageThread();

                this._model.sendMessage(body, this._thread.threadID);
              }
            }
            this.clear();
          ]]>
        </body>
      </method>

      <method name="focus">
        <body>
          <![CDATA[
            setTimeout(function(el){el.focus()}, 100, this._input);
          ]]>
        </body>
      </method>

      <method name="maybeResize">
        <body>
          <![CDATA[
          var chatOutputEl = this._output._output.contentDocument.body;
          var chatOutputScrollPos = chatOutputEl.scrollTop + chatOutputEl.clientHeight;

          this._inputClone.value = this._input.value;

          if (this._sizeOffset == null)
            this._sizeOffset = this._input.boxObject.height -
                this._input.inputField.offsetHeight;

          var h = this._sizeOffset + this._inputClone.inputField.scrollHeight;

          if (h > 0.3*window.innerHeight)
            h = 0.3*window.innerHeight;

          this._input.style.height = h + "px";

          chatOutputEl.scrollTop = chatOutputScrollPos - chatOutputEl.clientHeight;
          ]]>
        </body>
      </method>
    </implementation>

    <handlers>
      <handler event="selectedSmile">
        <![CDATA[
          var pos = this._input.selectionStart;

          this._input.value = this._input.value.substr(0, pos)+
            this._smilesList.selectedSmile.texts[0] +
            this._input.value.substr(this._input.selectionEnd);

          this._input.selectionStart = this._input.selectionEnd =
            pos + this._smilesList.selectedSmile.texts[0].length;
        ]]>
      </handler>
      <handler event="smilesToggle">
        <![CDATA[
          var enabled = this._contactInfo.parentNode.getAttribute("smiles-enabled") != "true"
          this._contactInfo.parentNode.setAttribute("smiles-enabled", enabled);
          this._output.smilesEnabled = enabled;
        ]]>
      </handler>
    </handlers>
  </binding>
</bindings>
