<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="chatpane-view">
    <resources>
      <stylesheet src="chrome://global/skin"/>
      <stylesheet src="chrome://messenger/skin/chatpane.css"/>
    </resources>

    <content>
      <html:iframe id="output" flex="1"/>
    </content>

    <implementation>
      <constructor>
        <![CDATA[
          var me = this;

          this._msgs = [];
          this._output = document.getAnonymousElementByAttribute(this, "id", "output");
// #ifdef XULAPP
          this._output.contentWindow.addEventListener("load", function(){me._onLoad()}, false);
/* #else
          this._output.addEventListener("load", function(){me._onLoad()}, false);
// #endif */
          this.colorMap = {me: 0};
          this.colorIndex = 1;
          this.colorTable = [
            "#ff0000", "#6978a3",
            "#46a", "#c4d", "#3b3", "#fa4", "#79c", "#a7a",
            "#4ca", "#c66", "#aaa", "#ca0", "#770", "#5cc",
          ];
        ]]>
      </constructor>

      <method name="_onLoad">
        <parameter name="event"/>
        <body>
          <![CDATA[
            if (!this._msgs)
              return;
            var link = this._output.contentDocument.createElement("link");
// #ifdef XULAPP
            link.setAttribute("href", "chrome://messenger/skin/chatpane-content.css");
/* #else
            link.setAttribute("href",
              document.location.href.replace(/content\/.*?$/, "skin/chatpane-content.css"));
// #endif */
            link.setAttribute("rel", "stylesheet");
            this._output.contentDocument.getElementsByTagName("HEAD")[0].appendChild(link);

            var colorScheme = "";
            var white = new RGBColor(1, 1, 1);
            for (var i = 0; i < this.colorTable.length; i++) {
              var base = new RGBColor(this.colorTable[i]);
              var bg = base.composite(white, 0.06);
              var border = base.composite(white, 0.3);

              colorScheme +=
                <style>
                  .messageChunk[color-id="{i}"] {"{"}
                      background: {bg};
                  }

                  .messageChunk[color-id="{i}"], .messageChunk[color-id="{i}"] .message {"{"}
                      border-color: {border};
                  }

                  .messageChunk[color-id="{i}"] .header {"{"}
                      background-color: {base}
                  }
                </style>;
            }

            var colorSchemeTag = this._output.contentDocument.createElement("style");
            colorSchemeTag.setAttribute("type", "text/css");
            colorSchemeTag.appendChild(this._output.contentDocument.createTextNode(colorScheme));
            this._output.contentDocument.getElementsByTagName("HEAD")[0].
              appendChild(colorSchemeTag);

            this._output.contentDocument.body.className = "smiles-enabled";

            for (var i = 0; i < account.iconsRegistry.smiles.length; i++)
              account.iconsRegistry.smiles[i].attachStyles(this._output.contentDocument);

            this._output.contentDocument.addEventListener("click", this._onClick, true)

            var msgs = this._msgs;
            this._msgs = null;
            for (var i = 0; i < msgs.length; i++)
              this.addMessage.apply(this, msgs[i]);
          ]]>
        </body>
      </method>

      <method name="_onClick">
        <parameter name="event"/>
        <body>
          <![CDATA[
            if ((event.button == 0 || event.button == 1) &&
                event.target.localName.toLowerCase() == "a")
            {
              event.preventDefault();
              event.stopPropagation();
              openLink(event.target.href);
            }
          ]]>
        </body>
      </method>

      <method name="addMessage">
        <parameter name="from"/>
        <parameter name="body"/>
        <parameter name="authorId"/>
        <parameter name="jid"/>
        <parameter name="timeStamp"/>
        <body>
          <![CDATA[
            if (this._msgs) {
              this._msgs.push([from, body, authorId, jid, timeStamp]);
              return;
            }

            var doc = this._output.contentDocument, mc;

            if (!this._content) {
              this._content = doc.createElement("div");
              doc.body.appendChild(this._content);
            }

            if (!this._mc || this._authorId != authorId) {
              this._mc = mc = doc.createElement("div");
              this._authorId = authorId;
              if (!(authorId in this.colorMap)) {
                this.colorMap[authorId] = this.colorIndex;
                this.colorIndex = this.colorIndex%(this.colorTable.length-1) + 1;
              }
              mc.setAttribute("class", "messageChunk");
              mc.setAttribute("author-id", authorId);
              mc.setAttribute("color-id", this.colorMap[authorId]);
              this._content.appendChild(mc)
            } else
              mc = this._mc;

            var m = doc.createElement("div");
            m.setAttribute("class", "message");
            mc.appendChild(m);

            var h = doc.createElement("div");
            h.setAttribute("class", "header");
            m.appendChild(h);

            var e = doc.createElement("div");
            e.setAttribute("class", "author");
            e.appendChild(doc.createTextNode(from));
            h.appendChild(e);

            var e = doc.createElement("div");
            e.setAttribute("class", "date");
            e.appendChild(doc.createTextNode(readableTimestamp(timeStamp||new Date())));
            h.appendChild(e);

            var e = doc.createElement("div");
            e.setAttribute("class", "body");
            var message = new Message(body);
            e.innerHTML = message.asHtml;
            m.appendChild(e);

            m.scrollIntoView(true);
          ]]>
        </body>
      </method>

      <method name="clear">
        <body>
          <![CDATA[
            if (this._content)
              this._content.parentNode.removeChild(this._content);
            this._mc = this._authorId = null;
            this._content = null;
          ]]>
        </body>
      </method>

    </implementation>
  </binding>

  <binding id="chatpane">

    <resources>
      <stylesheet src="chrome://global/skin"/>
      <stylesheet src="chrome://messenger/skin/chatpane.css"/>
    </resources>

    <content>
      <xul:vbox flex="1">
        <xul:hbox align="center" hidden="true">
          <xul:button label="Subject:"/>
          <xul:description id="subject" flex="1">TEST</xul:description>
        </xul:hbox>
        <xul:chatpane-view id="output-pane" flex="1"/>
        <xul:hbox align="center">
          <xul:deck flex="1">
            <xul:textbox id="input" flex="1" multiline="true" style="height: 1.7em"
                         oninput="this.parentNode.parentNode.parentNode.parentNode.maybeResize()"/>
            <xul:vbox flex="1">
              <xul:textbox id="inputClone" multiline="true" style="height: 1.7em"/>
            </xul:vbox>
          </xul:deck>
          <xul:button id="send" oncommand="this.parentNode.parentNode.parentNode._send()"/>
        </xul:hbox>
      </xul:vbox>
    </content>

    <implementation>

      <property name="content" readonly="true"
        onget="return this._input.value" />

      <property name="hasSubject"
        onset="this._subject.parentNode.hidden = !val; return val"
        onget="return !this._subject.parentNode.hidden" />

      <property name="subject"
        onset="return this._subject.value = val"
        onget="return this._subject.value" />

      <constructor>
        <![CDATA[
          this._scrollSize = 0;
          this.sendOnEnter = this.getAttribute("sendonenter") != "false";

          this._firstFocus = true;

          this._input = document.getAnonymousElementByAttribute(this, "id", "input");
          this._inputClone = document.getAnonymousElementByAttribute(this, "id", "inputClone");
          this._output = document.getAnonymousElementByAttribute(this, "id", "output-pane");
          this._subject = document.getAnonymousElementByAttribute(this, "id", "subject");

          var me = this;
          this._input.addEventListener("keypress",
            function (event) {
              if (event.keyCode == KeyEvent.DOM_VK_TAB)
                event.preventDefault();
              if (event.keyCode == KeyEvent.DOM_VK_RETURN &&
                  !event.shiftKey && me.sendOnEnter)
              {
                me._send();

                event.stopPropagation();
                event.preventDefault();
                return false;
              }
              return true;
            }, true);
          //this.maybeResize();
        ]]>
      </constructor>

      <method name="clear">
        <body>
          <![CDATA[
            this._input.value = ""
            this.maybeResize();
          ]]>
        </body>
      </method>

      <method name="addMessage">
        <body>
          <![CDATA[
            this._output.addMessage.apply(this._output, arguments);
          ]]>
        </body>
      </method>

      <method name="clearView">
        <body>
          <![CDATA[
            this._output.clear();
          ]]>
        </body>
      </method>

      <method name="_send">
        <body>
          <![CDATA[
            if (~this.content.search(/\S/)) {
              var ev = document.createEvent("Events");
              ev.initEvent("chat-send", true, false);
              this.dispatchEvent(ev);
            }
            this.clear();
          ]]>
        </body>
      </method>

      <method name="focus">
        <body>
          <![CDATA[
          window.setTimeout(function(a, b){b._firstFocus = false;a.focus()},
            this._firstFocus ? 500 : 0, this._input, this);
          ]]>
        </body>
      </method>

      <method name="maybeResize">
        <body>
          <![CDATA[
          this._inputClone.value = this._input.value;

          if (this._sizeOffset == null)
            this._sizeOffset = this._input.boxObject.height -
                this._input.inputField.offsetHeight;

          var h = this._sizeOffset + this._inputClone.inputField.scrollHeight;

          if (h > 0.3*window.innerHeight)
            h = 0.3*window.innerHeight;

          this._input.style.height = h + "px";
          ]]>
        </body>
      </method>

    </implementation>
  </binding>
</bindings>
